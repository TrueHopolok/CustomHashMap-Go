<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# hashmap

```go
import "github.com/TrueHopolok/CustomHashMap-Go"
```

hashmap desription TODO

## Index

- [Constants](<#constants>)
- [type HashMap](<#HashMap>)
  - [func MakeHashMap\[K Hashable, V any\]\(len uint64\) HashMap\[K, V\]](<#MakeHashMap>)
  - [func NewHashMap\[K Hashable, V any\]\(\) HashMap\[K, V\]](<#NewHashMap>)
  - [func \(m HashMap\[K, V\]\) Add\(key K, val V\) bool](<#HashMap[K, V].Add>)
  - [func \(m HashMap\[K, V\]\) All\(\) \[\]Item\[K, V\]](<#HashMap[K, V].All>)
  - [func \(m HashMap\[K, V\]\) Del\(key K\)](<#HashMap[K, V].Del>)
  - [func \(m HashMap\[K, V\]\) Get\(key K\) \(val V, exists bool\)](<#HashMap[K, V].Get>)
  - [func \(m HashMap\[K, V\]\) Has\(key K\) \(exists bool\)](<#HashMap[K, V].Has>)
  - [func \(m HashMap\[K, V\]\) Key\(\) \[\]K](<#HashMap[K, V].Key>)
  - [func \(m HashMap\[K, V\]\) Rem\(key K\) bool](<#HashMap[K, V].Rem>)
  - [func \(m HashMap\[K, V\]\) Req\(key K\) \(val V\)](<#HashMap[K, V].Req>)
  - [func \(m HashMap\[K, V\]\) Set\(key K, val V\)](<#HashMap[K, V].Set>)
  - [func \(m HashMap\[K, V\]\) Upd\(key K, val V\) bool](<#HashMap[K, V].Upd>)
  - [func \(m HashMap\[K, V\]\) Val\(\) \[\]V](<#HashMap[K, V].Val>)
- [type Hashable](<#Hashable>)
- [type HashableError](<#HashableError>)
  - [func \(e HashableError\) Error\(\) string](<#HashableError.Error>)
- [type IIError](<#IIError>)
  - [func \(e IIError\) Error\(\) string](<#IIError.Error>)
- [type InvalidLengthError](<#InvalidLengthError>)
  - [func \(e InvalidLengthError\) Error\(\) string](<#InvalidLengthError.Error>)
- [type Item](<#Item>)
- [type MaxCapExceededError](<#MaxCapExceededError>)
  - [func \(e MaxCapExceededError\) Error\(\) string](<#MaxCapExceededError.Error>)


## Constants

<a name="MAX_CAPACITY"></a>

```go
const (
    // MAX_CAPACITY that is allowed for allocation => max insertion capacity is 1 milliard.
    // That is around 1 gigabyte * sum of sizes of the key and value types.
    MAX_CAPACITY uint64 = 2_000_000_000

    // START_CAPACITY is how many elements are allowed to be inserted into default map created by [NewHashMap].
    START_CAPACITY uint64 = 64
)
```

<a name="HashMap"></a>
## type HashMap

HashMap is the main structure of the package. For indepth implementation, see this package's description.

```go
type HashMap[K Hashable, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="MakeHashMap"></a>
### func MakeHashMap

```go
func MakeHashMap[K Hashable, V any](len uint64) HashMap[K, V]
```

MakeHashMap creates new [HashMap](<#HashMap>) with reserved memory for given len parameter. Gurantees no resizing after calling this function until amount of inserted elements surpasses given length. Beaware, total memory allocated will be 2 times larger than given len to avoid collisions.

Time Complexity:

- O\(N\), where N is given length

Memory Complexity:

- O\(2N\), where N is given length

<a name="NewHashMap"></a>
### func NewHashMap

```go
func NewHashMap[K Hashable, V any]() HashMap[K, V]
```

NewHashMap creates new empty [HashMap](<#HashMap>) with reserved memory of base capacity.

<a name="HashMap[K, V].Add"></a>
### func \(HashMap\[K, V\]\) Add

```go
func (m HashMap[K, V]) Add(key K, val V) bool
```

Add inserts value into the [HashMap](<#HashMap>) as item with given key. Returns whether or not value was inserted into the [HashMap](<#HashMap>). May increase size of the [HashMap](<#HashMap>).

Items with hash of the key are stored in linked list, so any happend collision is handled by inserting item into the end of the linked list.

- To gurantee value getting saved into the item \(new or existing\) with given key, use \[Set\].
- To gurantee replacement of the old value, use \[Upd\].

Time Complexity:

- O\(1\) amortized, if \[Hashable.Hash\] is low\-collision
- O\(N\) worst, where N is current amount of elements

Memory Complexity:

- O\(1\) amortized
- O\(N\) worst, where N is current amount of elements

<a name="HashMap[K, V].All"></a>
### func \(HashMap\[K, V\]\) All

```go
func (m HashMap[K, V]) All() []Item[K, V]
```

All returns copy of all existing items in the [HashMap](<#HashMap>).

Time Complexity:

- O\(N\), where N is current amount of elements

Memory Complexity:

- O\(N\), where N is current amount of elements

<a name="HashMap[K, V].Del"></a>
### func \(HashMap\[K, V\]\) Del

```go
func (m HashMap[K, V]) Del(key K)
```

Del removes value with given key from the map. If such element does not exists, does nothing.

- To gurantee deletion of existing element, use \[Rem\].

Time Complexity:

- O\(1\), if \[Hashable.Hash\] is low\-collision

Memory Complexity:

- O\(1\)

<a name="HashMap[K, V].Get"></a>
### func \(HashMap\[K, V\]\) Get

```go
func (m HashMap[K, V]) Get(key K) (val V, exists bool)
```

Get returns value by given key and boolean indicating if such item exists. If item with given key does not exists, value will be initialized as default value and false will be returned.

Time Complexity:

- O\(1\), if \[Hashable.Hash\] is low\-collision

Memory Complexity:

- O\(1\)

<a name="HashMap[K, V].Has"></a>
### func \(HashMap\[K, V\]\) Has

```go
func (m HashMap[K, V]) Has(key K) (exists bool)
```

Has returns whether or not item with given key exists.

Time Complexity:

- O\(1\), if \[Hashable.Hash\] is low\-collision

Memory Complexity:

- O\(1\)

<a name="HashMap[K, V].Key"></a>
### func \(HashMap\[K, V\]\) Key

```go
func (m HashMap[K, V]) Key() []K
```

Key returns copy of all existing keys in the [HashMap](<#HashMap>).

Time Complexity:

- O\(N\), where N is current amount of elements

Memory Complexity:

- O\(N\), where N is current amount of elements

<a name="HashMap[K, V].Rem"></a>
### func \(HashMap\[K, V\]\) Rem

```go
func (m HashMap[K, V]) Rem(key K) bool
```

Rem removes value with given key from the map. Returns whether or not item was deleted.

- To gurantee deletion of the key without checking its existance, use \[Del\].

Time Complexity:

- O\(1\), if \[Hashable.Hash\] is low\-collision

Memory Complexity:

- O\(1\)

<a name="HashMap[K, V].Req"></a>
### func \(HashMap\[K, V\]\) Req

```go
func (m HashMap[K, V]) Req(key K) (val V)
```

Req returns value of the item with given key or default value of the type if item with given key does not exists.

Time Complexity:

- O\(1\), if \[Hashable.Hash\] is low\-collision

Memory Complexity:

- O\(1\)

<a name="HashMap[K, V].Set"></a>
### func \(HashMap\[K, V\]\) Set

```go
func (m HashMap[K, V]) Set(key K, val V)
```

Set replaces value of item in the [HashMap](<#HashMap>) with given key. May increase size of the [HashMap](<#HashMap>).

Items with hash of the key are stored in linked list, so any happend collision is handled by inserting item into the end of the linked list.

- To gurantee insertion of the value as a new item, use \[Add\].
- To gurantee replacement of the old value, use \[Upd\].

Time Complexity:

- O\(1\) amortized, if \[Hashable.Hash\] is low\-collision
- O\(N\) worst, where N is current amount of elements

Memory Complexity:

- O\(1\) amortized
- O\(N\) worst, where N is current amount of elements

<a name="HashMap[K, V].Upd"></a>
### func \(HashMap\[K, V\]\) Upd

```go
func (m HashMap[K, V]) Upd(key K, val V) bool
```

Upd updates value of item in the [HashMap](<#HashMap>) with given key. Returns whether or not value of the item was found and updated. Never increases size of the [HashMap](<#HashMap>).

- To gurantee value getting saved into the item \(new or existing\) with given key, use \[Set\].
- To gurantee insertion of the value as a new item, use \[Add\].

Time Complexity:

- O\(1\) amortized, if \[Hashable.Hash\] is low\-collision
- O\(N\) worst, where N is current amount of elements

Memory Complexity:

- O\(1\) amortized
- O\(N\) worst, where N is current amount of elements

<a name="HashMap[K, V].Val"></a>
### func \(HashMap\[K, V\]\) Val

```go
func (m HashMap[K, V]) Val() []V
```

Val returns copy of all existing values in the [HashMap](<#HashMap>).

Time Complexity:

- O\(N\), where N is current amount of elements

Memory Complexity:

- O\(N\), where N is current amount of elements

<a name="Hashable"></a>
## type Hashable

Hashable is interface implementing Hash function and comparison to be equal. Hash function should be low\-collision, otherwise time complexity may sky\-rocket.

For some type, Hashable interface is implemented in \[hashable\] package.

```go
type Hashable interface {
    // Hash returns a numeric representation (hash) of the instance.
    // Returned hash must be in range of [0;modulo).
    Hash(modulo uint64) uint64

    // Equal returns true if 2 instances are equal, or false otherwise.
    Equal(other Hashable) bool
}
```

<a name="HashableError"></a>
## type HashableError

HashableError indicate that provided hash function is returning value out of given 0 to modulo range.

```go
type HashableError struct {
    // contains filtered or unexported fields
}
```

<a name="HashableError.Error"></a>
### func \(HashableError\) Error

```go
func (e HashableError) Error() string
```



<a name="IIError"></a>
## type IIError

IIError \- Internal Implementation Error, something happend that should have been based on implementation.

```go
type IIError struct {
    // contains filtered or unexported fields
}
```

<a name="IIError.Error"></a>
### func \(IIError\) Error

```go
func (e IIError) Error() string
```



<a name="InvalidLengthError"></a>
## type InvalidLengthError

ZeroLengthError occurs only in [MakeHashMap](<#MakeHashMap>) if given length is zero or larger than [MAX\\\_CAPACITY](<#MAX_CAPACITY>) divided by 2.

```go
type InvalidLengthError struct{}
```

<a name="InvalidLengthError.Error"></a>
### func \(InvalidLengthError\) Error

```go
func (e InvalidLengthError) Error() string
```



<a name="Item"></a>
## type Item

Item is used only by \[All\] function to return slice of all items.

```go
type Item[K Hashable, V any] struct {
    Key K
    Val V
}
```

<a name="MaxCapExceededError"></a>
## type MaxCapExceededError

MaxCapExceededError indicate that capacity that was / will be requested is too large being larger than [MAX\\\_CAPACITY](<#MAX_CAPACITY>).

```go
type MaxCapExceededError struct{}
```

<a name="MaxCapExceededError.Error"></a>
### func \(MaxCapExceededError\) Error

```go
func (e MaxCapExceededError) Error() string
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
